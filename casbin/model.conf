[request_definition]
r = dom, sub, obj, act

[policy_definition]
p = dom, sub, obj, act

[role_definition]
g = _, _

[policy_effect]
# note: the space after "where" is important
e = some(where (p.eft == allow))

[matchers]
# matcher for internal use (see casbin middleware)
#m = r.dom == p.dom\
#    && g(r.sub, p.sub)\
#    && keyMatch2(r.obj, p.obj)\
#    && regexMatch(r.act, p.act)

# matcher for use by beacon
# Builtin Operators:
# keyMatch(s1, s2) matches if s1 matches s2 which might contain asterisks ("/foo/bar" matches "/foo/*")
# keyGet2(s1, s2, v) returns the part of s1 which matches s2 at the path variable v ("/resource1" matches "/:resource" with v="resource")
# regexMatch(s1, s2) matches if s1 matches s2 which might contain regular expressions ("/foo/bar" matches "/foo/[a-z]+")
m = r.dom == p.dom\
    && g(r.sub, p.sub)\
    && (keyMatch(r.obj, p.obj)\
        || r.sub == keyGet2(r.obj, p.obj, "username")\
        || g(keyGet2(r.obj, p.obj, "publicuser"), "role::public")\
    )\
    && regexMatch(r.act, p.act)

# keyMatch(r.obj, p.obj) allows for wildcard matching (e.g. Admin can access all resources)
# keyGet2(r.obj, p.obj, "username") for matching on the username in the resource path (e.g give "user1" access to the resource "/user/user1/model")
# g(keyGet2(r.obj, p.obj, "publicuser"), "role::public") for checking if the user in the resource path has the public role (e.g. give everyone read access to a public users resources)

# TODO: integrate ABAC to make user requesting own resource easier